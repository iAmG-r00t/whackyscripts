#!/usr/bin/env bash
# check status of CVE git directories
# inspo by victoriadrake [git-rundown]
# most code generated by OpenAI, workflow by iAmG-r00t

# fill the following below
review=""
complet=""
author_name=""

# assign arguments to review and complet
if [ -z "$1" ] && [ -z "$2" ]; then
    # if above is not set assumes they are
    # ... in the same directory as the script
    if [ -z "$review"]; then
        review="$(pwd)/review"
    fi

    if  [ -z "$complet" ]; then
        complet="$(pwd)/completed/"
    fi
else
    review="$1"
    complet="$2"
    author_name="$3"
fi

if [ ! -d "$review" ] || [ -d "$complet" ]; then
    echo -e "Usage:\n\t$(basename "$0") <review_dir_path> <complete_dir_path> <author_name>\n"
    echo -e "FYI: You can also avoid all this and fill in the first variables in the script"
    exit 1
fi

check_untr="untracked"
check_unpush="ahead"

ssh_key_missing="Add ssh-key to agent"

error_array=()
others_array=()
i=0
j=0

for dir in $(find "$review" -type d -name ".git"); do
    # get the parent directory of the .git directory
    parent_dir=$(dirname $dir)

    # print the name of the directory
    repo_dir=$(echo "$parent_dir" | cut -d "/" -f 9-)

    print_branch() {
        # print branch
        s=$(git status | head -n1)
        echo -en "\033[0;36m${s:10}\033[0m"

        # print repo dir path
        echo -en "\033[0;35m"
        echo " ${repo_dir}"
        echo -en "\033[0m"
    }

    cd $parent_dir

    # check if the origin repo has been updated
    fetch_output=$(git fetch 2>&1 | head -n 1 | grep -o "Permission denied (publickey).")

    # check if the ssh-key is added to ssh-agent
    if [ -n "$fetch_output" ]; then
        echo -e "\033[0;31m[!] \033[1;96m$ssh_key_missing\033[0m"
        exit 1
    fi

    # Check for untracked files
    if [[ $(git status | grep "$check_untr" -c) -ne 0 ]]; then
        # add repo_dir to others_array
        others_array[j]=$repo_dir
        ((j++))
    fi

    # Check for unpushed changes
    if [[ $(git status | grep "$check_unpush" -c) -ne 0 ]]; then
        # add repo_dir to others_array
        others_array[j]=$repo_dir
        ((j++))
    fi

    # check if origin/master has been updated
    HEADHASH=$(git rev-parse HEAD)
    UPSTREAMHASH=$(git rev-parse master@{upstream})
    LASTCOMMITHASH=$(git log --author="$author_name" -n 1 --format=%H)

    if [ "$HEADHASH" != "$UPSTREAMHASH" ]; then
        print_branch
        origin_updated=$(git status | sed -n '2p' | grep -o "^[^,]*")
        echo -e "\t\033[1;37m[!] \033[0;31m$origin_updated\033[0m"

        echo -e "\t\033[1;37m[+] \033[1;35mPulling 'origin/master' silently\033[0m"
        pull_output=$(git pull 2>&1 | sed 's/^/\t\t/')

        # if error when pulling show error message
        #if [ -n "$grep_result" ]; then
        if ! grep -qEw 'changed|insertion|deletions' <<< "$pull_output"; then
            echo -e "\t\033[0;31m[!] Git pull error:\033[0m"
            echo -e "$pull_output\n"

            # add repo_dir to error_array
            error_array[i]=$repo_dir
            ((i++))
        else
            echo -e "\t\033[1;33m[+] \033[0mMoving directory to completed directory"
            mv "$parent_dir" "$complet"
        fi
    elif [ "$HEADHASH" != "$LASTCOMMITHASH" ]; then
        # chances are the repo is already updated
        print_branch
        echo -e "\t\033[1;33m[+] \033[0mMoving directory to completed directory" 
        mv "$parent_dir" "$complet"
    fi
done

# list directories that faced a pull error
if [ ${#error_array[@]} -gt 0 ]; then
    echo -e "\n\033[0;31m[!]\033[0;33m Git pull error repo's:\033[0m"
    for dir in "${error_array[@]}"; do
        echo -e "\t$dir"
    done
    echo

    # echo ways to fix git merge conflicts
    echo -e "\n\033[1;33m[!] \033[0mWorkflow to fix merge conflicts"
    echo -e "\t\033[1;33m[-] \033[0mRemove the conflicting lines"
    echo -e "\t\033[1;33m[-] \033[0mAdd and do a local commit."
    echo -e "\t\033[1;33m[-] \033[0mDo a git pull, then a git log."
    echo -e "\t\033[1;33m[-] \033[0mGet the commit hash you want to place as head."
    echo -e "\t\033[1;33m[-] \033[0mRun 'git reset --hard <commit-hash>'"
fi

# list directories that contain untracked and unpushed files/changes
if [ ${#others_array[@]} -gt 0 ]; then
    echo -e "\n\033[0;31m[!]\033[0;33m Untracked files and unpushed changes repo's:\033[0m"
    for dir in "${others_array[@]}"; do
        echo -e "\t$dir"
    done
fi

# delete empty directories
empty_dir=$(find "$review" -maxdepth 2 -type d -empty)
if [ -n "$empty_dir" ]; then
    echo -e "\n\033[0;31m[!]\033[0;33m Deleting all empty directories in review path"
    find "$review" -maxdepth 2 -type d -empty -delete
fi
